
--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/main.py ---

import os
import re
import traceback
import pickle
import faiss
import fitz  # PyMuPDF
from datetime import datetime
from typing import List, Generator, AsyncGenerator, Dict, Any

from fastapi import FastAPI, Depends, HTTPException, UploadFile, File, Form
from fastapi import Path
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, StreamingResponse
from sqlalchemy.orm import Session

from sentence_transformers import SentenceTransformer
from groq import Groq, AuthenticationError

import json
import asyncio

import schemas
import models
from database import SessionLocal, engine
from speller import SpellingCorrector  # Our custom speller module

# Import the document-splitting logic
from chunker import split_document

# Import quiz logic
import quiz

# -----------------------
# Database setup
# -----------------------
models.Base.metadata.create_all(bind=engine)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# -----------------------
# FastAPI app + CORS
# -----------------------
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # adjust as needed
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# -----------------------
# Embedding model & storage dirs
# -----------------------
embedding_model = SentenceTransformer("all-MiniLM-L6-v2")
EMBED_DIM = embedding_model.get_sentence_embedding_dimension()

UPLOAD_DIR   = "shared_storage/uploaded_files"
VECTOR_ROOT  = "shared_storage/vector_stores"
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(VECTOR_ROOT, exist_ok=True)

# -----------------------
# Groq client (hardcoded API key)
# -----------------------
GROQ_API_KEY = "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"
groq_client  = Groq(api_key=GROQ_API_KEY)

# -----------------------
# Initialize our speller
# -----------------------
corrector = SpellingCorrector()

# -----------------------
# Utility: normalize question
# -----------------------
def normalize_question(q: str) -> str:
    """
    Lowercases, trims whitespace, and removes trailing punctuation.
    """
    q = q.lower().strip()
    q = re.sub(r"[?.!]+$", "", q)  # remove trailing ., ?, or !
    q = re.sub(r"\s+", " ", q)     # collapse multiple spaces
    return q

# -----------------------
# CRUD Endpoints
# -----------------------
@app.post("/courses/", response_model=schemas.Course)
def create_course(course: schemas.CourseCreate, db: Session = Depends(get_db)):
    db_c = models.Course(name=course.name)
    db.add(db_c)
    db.commit()
    db.refresh(db_c)
    return db_c

@app.get("/courses/", response_model=List[schemas.CourseOut])
def get_courses(db: Session = Depends(get_db)):
    return db.query(models.Course).all()

@app.get("/courses/{course_id}", response_model=schemas.Course)
def get_course(course_id: int, db: Session = Depends(get_db)):
    c = db.query(models.Course).get(course_id)
    if not c:
        raise HTTPException(404, "Course not found")
    return c

@app.put("/courses/{course_id}", response_model=schemas.Course)
def update_course(course_id: int, course: schemas.CourseCreate, db: Session = Depends(get_db)):
    c = db.query(models.Course).get(course_id)
    if not c:
        raise HTTPException(404, "Course not found")
    c.name = course.name
    db.commit()
    db.refresh(c)
    return c

@app.delete("/courses/{course_id}")
def delete_course(course_id: int, db: Session = Depends(get_db)):
    c = db.query(models.Course).get(course_id)
    if not c:
        raise HTTPException(404, "Course not found")
    db.delete(c)
    db.commit()
    return {"message": "Course deleted"}

@app.post("/courses/{course_id}/years/", response_model=schemas.Year)
def create_year(course_id: int, year: schemas.YearCreate, db: Session = Depends(get_db)):
    y = models.Year(name=year.name, course_id=course_id)
    db.add(y)
    db.commit()
    db.refresh(y)
    return y

@app.get("/courses/{course_id}/years/", response_model=List[schemas.Year])
def get_years(course_id: int, db: Session = Depends(get_db)):
    return db.query(models.Year).filter_by(course_id=course_id).all()

@app.put("/years/{year_id}", response_model=schemas.Year)
def update_year(year_id: int, year: schemas.YearCreate, db: Session = Depends(get_db)):
    y = db.query(models.Year).get(year_id)
    if not y:
        raise HTTPException(404, "Year not found")
    y.name = year.name
    db.commit()
    db.refresh(y)
    return y

@app.delete("/years/{year_id}")
def delete_year(year_id: int, db: Session = Depends(get_db)):
    y = db.query(models.Year).get(year_id)
    if not y:
        raise HTTPException(404, "Year not found")
    db.delete(y)
    db.commit()
    return {"message": "Year deleted"}

@app.post("/years/{year_id}/semesters/", response_model=schemas.Semester)
def create_semester(year_id: int, semester: schemas.SemesterCreate, db: Session = Depends(get_db)):
    s = models.Semester(name=semester.name, year_id=year_id)
    db.add(s)
    db.commit()
    db.refresh(s)
    return s

@app.get("/years/{year_id}/semesters/", response_model=List[schemas.Semester])
def get_semesters(year_id: int, db: Session = Depends(get_db)):
    return db.query(models.Semester).filter_by(year_id=year_id).all()

@app.put("/semesters/{semester_id}", response_model=schemas.Semester)
def update_semester(semester_id: int, semester: schemas.SemesterCreate, db: Session = Depends(get_db)):
    s = db.query(models.Semester).get(semester_id)
    if not s:
        raise HTTPException(404, "Semester not found")
    s.name = semester.name
    db.commit()
    db.refresh(s)
    return s

@app.delete("/semesters/{semester_id}")
def delete_semester(semester_id: int, db: Session = Depends(get_db)):
    s = db.query(models.Semester).get(semester_id)
    if not s:
        raise HTTPException(404, "Semester not found")
    db.delete(s)
    db.commit()
    return {"message": "Semester deleted"}

@app.post("/semesters/{semester_id}/units/", response_model=schemas.Unit)
def create_unit(semester_id: int, unit: schemas.UnitCreate, db: Session = Depends(get_db)):
    u = models.Unit(name=unit.name, semester_id=semester_id)
    db.add(u)
    db.commit()
    db.refresh(u)
    return u

@app.get("/semesters/{semester_id}/units/", response_model=List[schemas.Unit])
def get_units(semester_id: int, db: Session = Depends(get_db)):
    return db.query(models.Unit).filter_by(semester_id=semester_id).all()

# -----------------------
# Document Upload & Management
# -----------------------
@app.post("/documents/")
def upload_document(
    unit_id: int = Form(...),
    file: UploadFile = File(...),
    db: Session = Depends(get_db)
):
    ts       = datetime.now().strftime("%Y%m%d%H%M%S")
    filename = f"{ts}_{file.filename}"
    filepath = os.path.join(UPLOAD_DIR, filename)
    with open(filepath, "wb") as f:
        f.write(file.file.read())

    u = db.query(models.Unit).get(unit_id)
    if not u:
        raise HTTPException(404, "Unit not found")
    s = u.semester
    y = s.year
    c = y.course
    course_path = f"{c.name} → {y.name} → {s.name} → {u.name}"

    doc = models.Document(
        filename=file.filename,
        filepath=filepath,
        unit_id=unit_id,
        course_path=course_path
    )
    db.add(doc)
    db.commit()
    db.refresh(doc)
    return {"message": "Upload successful", "id": doc.id}

@app.get("/documents/", response_model=List[schemas.DocumentWithPath])
def list_documents(db: Session = Depends(get_db)):
    out = []
    for doc in db.query(models.Document).all():
        u = doc.unit; s = u.semester; y = s.year; c = y.course
        path = f"{c.name} → {y.name} → {s.name} → {u.name}"
        out.append(schemas.DocumentWithPath(
            id=doc.id, filename=doc.filename, filepath=doc.filepath, course_path=path
        ))
    return out

@app.get("/documents/download/{doc_id}")
def download_document(doc_id: int, db: Session = Depends(get_db)):
    doc = db.query(models.Document).get(doc_id)
    if not doc:
        raise HTTPException(404, "Document not found")
    return FileResponse(path=doc.filepath, filename=doc.filename, media_type="application/pdf")

@app.delete("/documents/{doc_id}")
def delete_document(doc_id: int, db: Session = Depends(get_db)):
    doc = db.query(models.Document).get(doc_id)
    if not doc:
        raise HTTPException(404, "Document not found")
    if os.path.exists(doc.filepath):
        os.remove(doc.filepath)
    db.delete(doc)
    db.commit()
    return {"message": "Document deleted"}

# -----------------------
# Process Document: Store heading, pages, source_file in metadata and database
# -----------------------
def process_document_stream(doc_id: int, db: Session) -> Generator[str, None, None]:
    """
    Streaming generator that
      1) Splits the PDF into chunks + metadata,
      2) Stores chunks in the database,
      3) Embeds each chunk, indexes/flattens into a FAISS index,
      4) Yields SSE lines so the front-end can show progress.
    """
    doc = db.query(models.Document).get(doc_id)
    if not doc:
        yield "data: Document not found\n\n"
        return

    yield f"data: Processing {doc.filename}...\n\n"
    try:
        chunks, metadata = split_document(
            doc.filepath,
            filename=doc.filename,
            max_words=500,
            overlap=100
        )
    except Exception as e:
        yield f"data: Failed during splitting: {e}\n\n"
        return

    yield f"data: Split into {len(chunks)} chunks.\n\n"

    if not chunks:
        yield "data: No chunks generated.\n\n"
        return

    # Store chunks in database
    for chunk_text, meta in zip(chunks, metadata):
        chunk = models.Chunk(
            document_id=doc.id,
            text=chunk_text,
            heading=meta.get("heading"),
            pages=json.dumps(meta.get("pages"))
        )
        db.add(chunk)
    db.commit()

    # Embed + index each chunk
    embeddings = embedding_model.encode(chunks)
    unit_dir   = os.path.join(VECTOR_ROOT, f"unit_{doc.unit_id}")
    os.makedirs(unit_dir, exist_ok=True)

    idx_path = os.path.join(unit_dir, "index.faiss")
    map_path = os.path.join(unit_dir, "doc_id_map.pkl")

    if os.path.exists(idx_path):
        index = faiss.read_index(idx_path)
        with open(map_path, "rb") as f:
            doc_map = pickle.load(f)
    else:
        index  = faiss.IndexFlatL2(EMBED_DIM)
        doc_map = {}

    base = index.ntotal
    index.add(embeddings)
    for i, chunk_text in enumerate(chunks):
        doc_map[base + i] = {
            "doc_id":     doc.id,
            "text":       chunk_text,
            "heading":    metadata[i].get("heading"),
            "pages":      metadata[i].get("pages"),
            "source_file": metadata[i].get("source_file")
        }

    faiss.write_index(index, idx_path)
    with open(map_path, "wb") as f:
        pickle.dump(doc_map, f)

    yield "data: Processing complete!\n\n"

@app.get("/documents/{doc_id}/process")
def process_document(doc_id: int, db: Session = Depends(get_db)):
    return StreamingResponse(process_document_stream(doc_id, db), media_type="text/event-stream")

# -----------------------
# Return chunks + metadata (inspection)
# -----------------------
@app.get("/documents/{doc_id}/chunks", response_model=List[Dict[str, Any]])
def get_document_chunks(doc_id: int, db: Session = Depends(get_db)):
    """
    Return all chunks + metadata for a given document,
    so you can inspect headings/pages and verify chunking correctness.
    """
    doc = db.query(models.Document).get(doc_id)
    if not doc:
        raise HTTPException(404, "Document not found")

    try:
        chunks, metadata = split_document(
            doc.filepath,
            filename=doc.filename,
            max_words=500,
            overlap=100
        )
    except Exception as e:
        raise HTTPException(500, f"Error splitting document: {e}")

    response = []
    for meta, chunk_text in zip(metadata, chunks):
        response.append({
            "chunk_index": meta["chunk_index"],
            "heading":     meta.get("heading"),
            "text":        chunk_text,
            "pages":       meta.get("pages")
        })

    return response

@app.get("/units/{unit_id}/documents/", response_model=List[schemas.DocumentWithPath])
def get_unit_documents(unit_id: int = Path(...), db: Session = Depends(get_db)):
    docs = db.query(models.Document).filter(models.Document.unit_id == unit_id).all()
    out = []
    for doc in docs:
        # These relationships should already be loaded due to how SQLAlchemy works
        # and because `doc.unit` is accessed. If `doc.unit` is None, it means
        # the foreign key `unit_id` is pointing to a non-existent unit, which
        # implies data integrity issues or an incomplete setup.
        # Adding a check here for robustness, though the underlying data should be correct.
        u = doc.unit
        if not u:
            print(f"Warning: Document ID {doc.id} references a missing Unit ID {doc.unit_id}")
            continue # Skip this document or handle as an error

        s = u.semester
        if not s:
            print(f"Warning: Unit ID {u.id} references a missing Semester ID {u.semester_id}")
            continue

        y = s.year
        if not y:
            print(f"Warning: Semester ID {s.id} references a missing Year ID {s.year_id}")
            continue

        c = y.course
        if not c:
            print(f"Warning: Year ID {y.id} references a missing Course ID {y.course_id}")
            continue

        path = f"{c.name} → {y.name} → {s.name} → {u.name}"
        out.append(schemas.DocumentWithPath(
            id=doc.id,
            filename=doc.filename,
            filepath=doc.filepath,
            course_path=path
        ))
    return out

# -----------------------
# ASK Endpoint (non-streaming)
# -----------------------
@app.post("/ask")
def ask_question(request: schemas.AskRequest, db: Session = Depends(get_db)):
    try:
        normalized_query = normalize_question(request.question)

        # Spell-correct
        corrected_query = corrector.correct_sentence(normalized_query)

        # Load FAISS index & doc_map for that unit
        unit_dir = os.path.join(VECTOR_ROOT, f"unit_{request.unit_id}")
        idx_path = os.path.join(unit_dir, "index.faiss")
        map_path = os.path.join(unit_dir, "doc_id_map.pkl")
        if not (os.path.exists(idx_path) and os.path.exists(map_path)):
            return {
                "answer": "No vector store found for this unit. Please upload & process documents first.",
                "citations": []
            }

        index = faiss.read_index(idx_path)
        with open(map_path, "rb") as f:
            doc_map = pickle.load(f)

        # Search for top-5 chunks
        question_embedding = embedding_model.encode([corrected_query])
        _, I = index.search(question_embedding, k=5)
        top_indices = [i for i in I[0] if i in doc_map]

        # Build context for the LLM prompt
        context = "\n".join(doc_map[i]["text"] for i in top_indices)
        prompt = f"""
You are a helpful tutor. Use the notes below to answer the student's question. Provide a clear, concise answer:

Notes:
{context}

Question: {request.question}
Answer:
"""

        completion = groq_client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[
                {"role": "system", "content": "You are a helpful tutor."},
                {"role": "user",   "content": prompt}
            ]
        )
        answer = completion.choices[0].message.content.strip()

        # Build citations
        citations = [
            {
                "heading":   doc_map[i].get("heading"),
                "pages":     doc_map[i].get("pages"),
                "file":      doc_map[i].get("source_file"),
            }
            for i in top_indices
        ]

        # Remove exact duplicates while preserving order
        seen = set()
        unique_citations = []
        for c in citations:
            c_str = json.dumps(c, sort_keys=True)
            if c_str not in seen:
                seen.add(c_str)
                unique_citations.append(c)

        return {
            "answer": answer,
            "citations": unique_citations
        }

    except AuthenticationError:
        raise HTTPException(502, "Groq authentication failed—check your API key")
    except HTTPException:
        raise
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(500, str(e))

# -----------------------
# ASK Streaming Endpoint
# -----------------------
@app.post("/ask/stream")
async def ask_question_stream(request: schemas.AskRequest, db: Session = Depends(get_db)):
    async def generate_streaming_response() -> AsyncGenerator[str, None]:
        try:
            normalized_query = normalize_question(request.question)
            corrected_query = corrector.correct_sentence(normalized_query)

            # Load FAISS index & doc_map
            unit_dir = os.path.join(VECTOR_ROOT, f"unit_{request.unit_id}")
            idx_path = os.path.join(unit_dir, "index.faiss")
            map_path = os.path.join(unit_dir, "doc_id_map.pkl")
            if not (os.path.exists(idx_path) and os.path.exists(map_path)):
                msg = "No vector store found for this unit. Please upload & process documents first."
                for i, word in enumerate(msg.split()):
                    token = word if i == 0 else f" {word}"
                    data = json.dumps({"token": token})
                    yield f"data: {data}\n\n"
                    await asyncio.sleep(0.03)
                # Send empty citations array, then [DONE]
                yield f"data: {json.dumps({'citations': []})}\n\n"
                yield "data: [DONE]\n\n"
                return

            index = faiss.read_index(idx_path)
            with open(map_path, "rb") as f:
                doc_map = pickle.load(f)

            # Search top-5 chunks
            question_embedding = embedding_model.encode([corrected_query])
            _, I = index.search(question_embedding, k=5)
            top_indices = [i for i in I[0] if i in doc_map]

            # Build prompt context
            context = "\n".join(doc_map[i]["text"] for i in top_indices)
            prompt = f"""
You are a helpful tutor. Use the notes below to answer the student's question. Provide a clear, concise answer:

Notes:
{context}

Question: {request.question}
Answer:
"""

            # Stream from Groq
            stream = groq_client.chat.completions.create(
                model="llama3-70b-8192",
                messages=[
                    {"role": "system", "content": "You are a helpful tutor."},
                    {"role": "user",   "content": prompt}
                ],
                stream=True,
                temperature=0.7,
                max_tokens=1000,
            )

            # Emit tokens as SSE
            for chunk in stream:
                if chunk.choices[0].delta.content:
                    token = chunk.choices[0].delta.content
                    data = json.dumps({"token": token})
                    yield f"data: {data}\n\n"
                    await asyncio.sleep(0.01)

            # Build citations
            citations = [
                {
                    "heading":   doc_map[i].get("heading"),
                    "pages":     doc_map[i].get("pages"),
                    "file":      doc_map[i].get("source_file"),
                }
                for i in top_indices
            ]

            # Remove exact duplicates while preserving order
            seen = set()
            unique_citations = []
            for c in citations:
                c_str = json.dumps(c, sort_keys=True)
                if c_str not in seen:
                    seen.add(c_str)
                    unique_citations.append(c)

            # At end, send the unique citations array
            yield f"data: {json.dumps({'citations': unique_citations})}\n\n"
            yield "data: [DONE]\n\n"

        except AuthenticationError:
            err = "Groq authentication failed—check your API key"
            for i, word in enumerate(err.split()):
                token = word if i == 0 else f" {word}"
                data = json.dumps({"token": token})
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.03)
            # End with no citations
            yield f"data: {json.dumps({'citations': []})}\n\n"
            yield "data: [DONE]\n\n"

        except Exception as e:
            err = str(e)
            for i, word in enumerate(err.split()):
                token = word if i == 0 else f" {word}"
                data = json.dumps({"token": token})
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.03)
            yield f"data: {json.dumps({'citations': []})}\n\n"
            yield "data: [DONE]\n\n"

    return StreamingResponse(
        generate_streaming_response(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "Access-Control-Allow-Origin": "http://localhost:3000",
            "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
        }
    )

# -----------------------
# ASK Stream-Simulated Endpoint
# -----------------------
@app.post("/ask/stream-simulated")
async def ask_question_stream_simulated(request: schemas.AskRequest, db: Session = Depends(get_db)):
    async def simulate_streaming_response() -> AsyncGenerator[str, None]:
        try:
            unit_dir = os.path.join(VECTOR_ROOT, f"unit_{request.unit_id}")
            idx_path = os.path.join(unit_dir, "index.faiss")
            map_path = os.path.join(unit_dir, "doc_id_map.pkl")
            if not (os.path.exists(idx_path) and os.path.exists(map_path)):
                msg = "No vector store found for this unit. Please upload & process documents first."
                for i, word in enumerate(msg.split()):
                    token = word if i == 0 else f" {word}"
                    data = json.dumps({"token": token})
                    yield f"data: {data}\n\n"
                    await asyncio.sleep(0.03)
                yield "data: [DONE]\n\n"
                return

            index = faiss.read_index(idx_path)
            with open(map_path, "rb") as f:
                doc_map = pickle.load(f)

            original_query  = request.question
            corrected_query = corrector.correct_sentence(original_query)

            question_embedding = embedding_model.encode([corrected_query])
            _, I = index.search(question_embedding, k=5)
            chunks = [doc_map[i]["text"] for i in I[0] if i in doc_map]

            context = "\n".join(f"- {c}" for c in chunks)
            prompt = f"""
You are a helpful tutor. Based on the notes below, answer the student's question.

Notes:
{context}

Question: {original_query}
Answer:
"""

            completion = groq_client.chat.completions.create(
                model="llama3-70b-8192",
                messages=[
                    {"role": "system", "content": "You are a helpful tutor."},
                    {"role": "user",   "content": prompt}
                ]
            )
            full_answer = completion.choices[0].message.content.strip()
            words = full_answer.split()

            for i, word in enumerate(words):
                token = word if i == 0 else f" {word}"
                data = json.dumps({"token": token})
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.05)

            yield "data: [DONE]\n\n"

        except AuthenticationError:
            err = "Groq authentication failed—check your API key"
            for i, word in enumerate(err.split()):
                token = word if i == 0 else f" {word}"
                data = json.dumps({"token": token})
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.03)
            yield "data: [DONE]\n\n"

        except Exception as e:
            err = str(e)
            for i, word in enumerate(err.split()):
                token = word if i == 0 else f" {word}"
                data = json.dumps({"token": token})
                yield f"data: {data}\n\n"
                await asyncio.sleep(0.03)
            yield "data: [DONE]\n\n"

    return StreamingResponse(
        simulate_streaming_response(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "Access-Control-Allow-Origin": "http://localhost:3000",
            "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
        }
    )

# -----------------------
# Course Tree endpoint
# -----------------------
@app.get("/tree/", response_model=List[schemas.Course])
def get_course_tree(db: Session = Depends(get_db)):
    return db.query(models.Course).all()

# -----------------------
# Quiz Management
# -----------------------
@app.get("/documents/{doc_id}/generate-quiz")
def generate_quiz(doc_id: int, db: Session = Depends(get_db)):
    return StreamingResponse(quiz.generate_quiz_for_document(doc_id, db), media_type="text/event-stream")

@app.get("/units/{unit_id}/quizzes", response_model=List[schemas.QuizQuestion])
def get_quizzes(unit_id: int, db: Session = Depends(get_db)):
    quizzes = db.query(models.QuizQuestion).filter(models.QuizQuestion.unit_id == unit_id).all()
    return quizzes

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/main.py ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/models.py ---

from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
import json

Base = declarative_base()

class Course(Base):
    __tablename__ = 'courses'
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    years = relationship("Year", back_populates="course", cascade="all, delete")

class Year(Base):
    __tablename__ = 'years'
    id = Column(Integer, primary_key=True, index=True)
    course_id = Column(Integer, ForeignKey("courses.id"), nullable=False)
    name = Column(String, nullable=False)
    course = relationship("Course", back_populates="years")
    semesters = relationship("Semester", back_populates="year", cascade="all, delete")

class Semester(Base):
    __tablename__ = 'semesters'
    id = Column(Integer, primary_key=True, index=True)
    year_id = Column(Integer, ForeignKey("years.id"), nullable=False)
    name = Column(String, nullable=False)
    year = relationship("Year", back_populates="semesters")
    units = relationship("Unit", back_populates="semester", cascade="all, delete")

class Unit(Base):
    __tablename__ = 'units'
    id = Column(Integer, primary_key=True, index=True)
    semester_id = Column(Integer, ForeignKey("semesters.id"), nullable=False)
    name = Column(String, nullable=False)
    semester = relationship("Semester", back_populates="units")
    documents = relationship("Document", back_populates="unit", cascade="all, delete")
    quiz_questions = relationship("QuizQuestion", back_populates="unit", cascade="all, delete")

class Document(Base):
    __tablename__ = 'documents'
    id = Column(Integer, primary_key=True, index=True)
    unit_id = Column(Integer, ForeignKey("units.id"), nullable=False)
    filename = Column(String, nullable=False)
    filepath = Column(String, nullable=False)
    course_path = Column(String, nullable=False)
    processed = Column(Integer, default=0)
    unit = relationship("Unit", back_populates="documents")
    chunks = relationship("Chunk", back_populates="document", cascade="all, delete")

class Chunk(Base):
    __tablename__ = 'chunks'
    id = Column(Integer, primary_key=True, index=True)
    document_id = Column(Integer, ForeignKey("documents.id"), nullable=False)
    text = Column(String, nullable=False)
    heading = Column(String)
    pages = Column(String)  # Store as JSON for lists
    document = relationship("Document", back_populates="chunks")
    quiz_questions = relationship("QuizQuestion", back_populates="chunk", cascade="all, delete")

class QuizQuestion(Base):
    __tablename__ = 'quiz_questions'
    id = Column(Integer, primary_key=True, index=True)
    unit_id = Column(Integer, ForeignKey("units.id"), nullable=False)
    question = Column(String, nullable=False)
    options = Column(String, nullable=False)  # Store as JSON string
    correct_answer = Column(String, nullable=False)
    explanation = Column(String)
    chunk_id = Column(Integer, ForeignKey("chunks.id"))
    unit = relationship("Unit", back_populates="quiz_questions")
    chunk = relationship("Chunk", back_populates="quiz_questions")

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/models.py ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/quiz.py ---

from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session
from groq import Groq
import json
import models
import schemas

groq_client = Groq()  # Assumes Groq client is initialized elsewhere (e.g., in main.py)

def generate_question_for_chunk(chunk_text: str) -> dict:
    """
    Generate a multiple-choice question from a text chunk using Groq API.
    Returns a dictionary with question, options, correct answer, and explanation.
    """
    prompt = f"""
Generate a multiple-choice question with four options based on the following text. Also provide an explanation for the correct answer. Output in JSON format with the structure:
{{
  "question": "The question text",
  "options": ["Option A", "Option B", "Option C", "Option D"],
  "correct_answer": "A",
  "explanation": "Explanation of why this is correct"
}}

Text: {chunk_text}
"""
    try:
        completion = groq_client.chat.completions.create(
            model="llama3-70b-8192",
            messages=[
                {"role": "system", "content": "You are a question generator that outputs JSON."},
                {"role": "user", "content": prompt}
            ],
            response_format={"type": "json_object"}
        )
        return json.loads(completion.choices[0].message.content)
    except Exception as e:
        raise Exception(f"Failed to generate question: {str(e)}")

def generate_quiz_for_document(doc_id: int, db: Session):
    """
    Generate quiz questions for a document by processing its chunks.
    Yields JSON strings with progress and questions generated.
    """
    doc = db.query(models.Document).get(doc_id)
    if not doc:
        yield "data: {\"error\": \"Document not found\"}\n\n"
        return

    chunks = db.query(models.Chunk).filter_by(document_id=doc_id).all()
    total = len(chunks)
    if total == 0:
        yield "data: {\"error\": \"No chunks found for document\"}\n\n"
        return

    for i, chunk in enumerate(chunks):
        try:
            question_data = generate_question_for_chunk(chunk.text)
            quiz_question = models.QuizQuestion(
                unit_id=doc.unit_id,
                question=question_data["question"],
                options=json.dumps(question_data["options"]),
                correct_answer=question_data["correct_answer"],
                explanation=question_data.get("explanation", ""),
                chunk_id=chunk.id
            )
            db.add(quiz_question)
            db.commit()
            progress = int((i + 1) / total * 100)
            yield f"data: {json.dumps({'progress': progress, 'questionsGenerated': i + 1})}\n\n"
        except Exception as e:
            yield f"data: {json.dumps({'error': f'Error generating question: {str(e)}'})}\n\n"
            continue

    yield "data: [DONE]\n\n"
--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/quiz.py ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/schemas.py ---

from pydantic import BaseModel
from typing import List, Optional

# =========================
# SHARED INPUT SCHEMAS
# =========================

class CourseBase(BaseModel):
    name: str

class CourseCreate(CourseBase):
    pass

class YearBase(BaseModel):
    name: str

class YearCreate(YearBase):
    pass

class SemesterBase(BaseModel):
    name: str

class SemesterCreate(SemesterBase):
    pass

class UnitBase(BaseModel):
    name: str

class UnitCreate(UnitBase):
    pass

# =========================
# OUTPUT MODELS (NESTED)
# =========================

class Unit(BaseModel):
    id: int
    name: str

    class Config:
        from_attributes = True

class Semester(BaseModel):
    id: int
    name: str
    units: List[Unit] = []

    class Config:
        from_attributes = True

class Year(BaseModel):
    id: int
    name: str
    semesters: List[Semester] = []

    class Config:
        from_attributes = True

class Course(BaseModel):
    id: int
    name: str
    years: List[Year] = []

    class Config:
        from_attributes = True

# =========================
# FLAT OUTPUTS (FOR LISTING)
# =========================

class CourseOut(BaseModel):
    id: int
    name: str

    class Config:
        from_attributes = True

class YearOut(BaseModel):
    id: int
    name: str

    class Config:
        from_attributes = True

class SemesterOut(BaseModel):
    id: int
    name: str

    class Config:
        from_attributes = True

class UnitOut(BaseModel):
    id: int
    name: str

    class Config:
        from_attributes = True

# =========================
# DOCUMENT SCHEMAS
# =========================

class DocumentBase(BaseModel):
    filename: str
    filepath: str
    unit_id: int

class Document(DocumentBase):
    id: int

    class Config:
        from_attributes = True

class DocumentWithPath(BaseModel):
    id: int
    filename: str
    filepath: str
    course_path: str  # e.g., "CS → Year 1 → Sem 2 → Data Structures"

    class Config:
        from_attributes = True

# =========================
# ASK REQUEST SCHEMA
# =========================

class AskRequest(BaseModel):
    unit_id: int
    question: str

# =========================
# QUIZ QUESTION SCHEMA
# =========================

class QuizQuestion(BaseModel):
    id: int
    unit_id: int
    question: str
    options: str  # JSON string of options
    correct_answer: str
    explanation: Optional[str] = None # Make explanation optional for the schema
    chunk_id: Optional[int] = None # Make chunk_id optional for the schema

    class Config:
        from_attributes = True

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/schemas.py ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/chunker.py ---

import fitz  # PyMuPDF
import pdfplumber
from typing import List, Tuple, Dict, Optional
import logging
from collections import defaultdict

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ChunkMetadata(Dict):
    chunk_index: int
    heading: str
    source_file: str
    pages: List[str]

def detect_headings_by_fontsize(
    page: fitz.Page,
    min_font_size: float = 12.0,  # Lowered for proposals
    max_words: int = 20  # Increased for longer headings in legal docs
) -> List[Tuple[str, Tuple[float, float, float, float], float]]:
    """Detect headings based on font size and layout."""
    headings = []
    try:
        page_dict = page.get_text("dict")
        blocks = page_dict.get("blocks", [])
        for block in blocks:
            if block.get("type") == 0:
                for line in block.get("lines", []):
                    for span in line.get("spans", []):
                        size = span.get("size", 0)
                        text = span.get("text", "").strip()
                        if (
                            text
                            and size >= min_font_size
                            and not text.islower()
                            and len(text.split()) < max_words
                            and not text.startswith(("0", "1", "2", "3", "4", "5", "6", "7", "8", "9"))  # Avoid numbered lists
                        ):
                            headings.append((text, span.get("bbox", (0, 0, 0, 0)), size))
    except Exception as e:
        logger.error(f"Error detecting headings on page {page.number}: {e}")
    seen = set()
    return [
        (h[0], h[1], h[2])
        for h in sorted(headings, key=lambda x: x[1][1])
        if h[0] not in seen and not seen.add(h[0])
    ]

def extract_tables_from_pdf(pdf_path: str) -> Dict[int, List[str]]:
    """Extract tables from PDF using pdfplumber."""
    tables = {}
    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page_num, page in enumerate(pdf.pages):
                page_tables = []
                # Use explicit table settings for better detection
                extracted_tables = page.extract_tables({
                    "vertical_strategy": "lines",
                    "horizontal_strategy": "lines",
                    "keep_blank_chars": True
                })
                for table in extracted_tables:
                    markdown_table = table_to_markdown(table)
                    if markdown_table:
                        page_tables.append(markdown_table)
                tables[page_num] = page_tables
    except Exception as e:
        logger.error(f"Error extracting tables from PDF {pdf_path}: {e}")
        return {}
    return tables

def table_to_markdown(table: List[List]) -> str:
    """Convert table data to Markdown format."""
    if not table or not isinstance(table, list) or not isinstance(table[0], list) or not table[0]:
        return ""
    col_count = len(table[0])
    table = [[("" if cell is None else str(cell).strip()) for cell in row] for row in table if len(row) == col_count]
    if not table:
        return ""
    header = "| " + " | ".join(table[0]) + " |"
    sep = "| " + " | ".join("---" for _ in table[0]) + " |"
    body = "\n".join("| " + " | ".join(row) + " |" for row in table[1:])
    return f"{header}\n{sep}\n{body}"

def extract_page_text_with_words(
    page: fitz.Page, clip: Optional[Tuple[float, float, float, float]] = None
) -> Tuple[str, List[Tuple[str, int]]]:
    """Extract text and word-to-page mapping from a page with optional clipping."""
    try:
        text = page.get_text("text", clip=clip).strip()
        words_data = page.get_text("words", clip=clip)  # Returns (x0, y0, x1, y1, word, block_no, line_no, word_no)
        word_page_map = [(word[4], page.number) for word in words_data]
        return text, word_page_map
    except Exception as e:
        logger.error(f"Error extracting text from page {page.number}: {e}")
        return "", []

def chunk_section(
    section_text: str,
    heading: str,
    word_page_map: List[Tuple[str, int]],
    real_labels: List[str],
    filename: str,
    max_words: int,
    overlap: int,
    chunk_index: int
) -> Tuple[List[str], List[ChunkMetadata], int]:
    """Chunk a section of text with precise page metadata."""
    chunks, metadata = [], []
    words = section_text.split()
    total_words = len(words)

    if not word_page_map:
        # Fallback to approximation if no word-page mapping
        words_per_page = max(1, total_words // max(1, len(real_labels)))
        start_word = 0
        while start_word < total_words:
            end_word = min(start_word + max_words, total_words)
            sub_words = words[start_word:end_word]
            if not sub_words:
                break
            sub_text = " ".join(sub_words)
            chunk_text = f"== {heading} ==\n{sub_text}"
            approx_start = min(start_word // words_per_page, len(real_labels) - 1)
            approx_end = min((end_word - 1) // words_per_page, len(real_labels) - 1)
            sub_pages = real_labels[approx_start:approx_end + 1]
            chunks.append(chunk_text)
            metadata.append({
                "chunk_index": chunk_index,
                "heading": heading or "No heading detected",
                "source_file": filename,
                "pages": sub_pages
            })
            chunk_index += 1
            start_word += max_words - overlap
        return chunks, metadata, chunk_index

    # Use word-page mapping for precise page assignment
    start_word = 0
    word_idx = 0
    while start_word < total_words:
        end_word = min(start_word + max_words, total_words)
        sub_words = words[start_word:end_word]
        if not sub_words:
            break
        sub_text = " ".join(sub_words)
        chunk_text = f"== {heading} ==\n{sub_text}"

        # Find pages for this chunk
        page_counts = defaultdict(int)
        word_count = 0
        for word, page_num in word_page_map:
            if word_idx <= word_count < word_idx + (end_word - start_word):
                page_counts[page_num] += 1
            word_count += 1
        # Assign the page with the most words, or fall back to range
        if page_counts:
            most_common_page = max(page_counts, key=page_counts.get)
            sub_pages = [real_labels[most_common_page] if most_common_page < len(real_labels) else str(most_common_page + 1)]
            # Include multiple pages only for large chunks
            if end_word - start_word > max_words // 2 and len(page_counts) > 1:
                sub_pages = [
                    real_labels[p] if p < len(real_labels) else str(p + 1)
                    for p in sorted(page_counts.keys())
                ]
        else:
            sub_pages = real_labels[:]

        chunks.append(chunk_text)
        metadata.append({
            "chunk_index": chunk_index,
            "heading": heading or "No heading detected",
            "source_file": filename,
            "pages": sub_pages
        })
        chunk_index += 1
        start_word += max_words - overlap
        word_idx += max_words - overlap
    return chunks, metadata, chunk_index

def split_document(
    pdf_path: str,
    *,
    filename: str = None,
    max_words: int = 300,  # Reduced for precise citations
    overlap: int = 50     # Reduced to minimize redundancy
) -> Tuple[List[str], List[ChunkMetadata]]:
    """Split PDF into chunks with headings, tables, and precise page metadata."""
    if not pdf_path.endswith(".pdf"):
        raise ValueError("Invalid PDF path")
    if max_words <= 0 or overlap < 0 or overlap >= max_words:
        raise ValueError("Invalid max_words or overlap values")

    chunks, metadata = [], []
    chunk_index = 0
    filename = filename or pdf_path

    try:
        with fitz.open(pdf_path) as doc:
            try:
                toc = doc.get_toc()
                use_outline = toc and len(toc) > 1
            except Exception as e:
                logger.error(f"Error reading TOC: {e}")
                use_outline = False

            tables_by_page = extract_tables_from_pdf(pdf_path)

            if use_outline:
                try:
                    labels = doc.get_page_labels()
                except Exception:
                    labels = [str(i + 1) for i in range(doc.page_count)]
                outline_sections = []
                for idx, (level, title, pg) in enumerate(toc):
                    if level in (1, 2):
                        start = max(0, min(doc.page_count - 1, pg - 1))
                        end = min(doc.page_count - 1, toc[idx + 1][2] - 2 if idx + 1 < len(toc) else doc.page_count - 1)
                        if start <= end:
                            outline_sections.append((title, start, end))
                for heading, start_pg, end_pg in outline_sections:
                    real_labels, pages_text, word_page_map = [], [], []
                    for p in range(start_pg, end_pg + 1):
                        if p >= doc.page_count:
                            continue
                        real_labels.append(labels[p] if p < len(labels) else str(p + 1))
                        page = doc.load_page(p)
                        for tbl in tables_by_page.get(p, []):
                            chunks.append(f"== {heading} ==\n{tbl}")
                            metadata.append({
                                "chunk_index": chunk_index,
                                "heading": heading,
                                "source_file": filename,
                                "pages": [real_labels[-1]]  # Exact page for table
                            })
                            chunk_index += 1
                        text, page_words = extract_page_text_with_words(page)
                        if text:  # Skip empty pages
                            pages_text.append(text)
                            word_page_map.extend(page_words)
                    section_text = "\n".join(p for p in pages_text if p).strip()
                    if section_text:
                        section_chunks, section_metadata, chunk_index = chunk_section(
                            section_text, heading, word_page_map, real_labels, filename, max_words, overlap, chunk_index
                        )
                        chunks.extend(section_chunks)
                        metadata.extend(section_metadata)
            else:
                try:
                    labels = doc.get_page_labels()
                except Exception:
                    labels = [str(i + 1) for i in range(doc.page_count)]
                for pno in range(doc.page_count):
                    page = doc.load_page(pno)
                    real_label = labels[pno] if pno < len(labels) else str(pno + 1)
                    headings = detect_headings_by_fontsize(page)
                    page_text, word_page_map = extract_page_text_with_words(page)
                    for tbl in tables_by_page.get(pno, []):
                        chunks.append(f"== No heading ==\n{tbl}")
                        metadata.append({
                            "chunk_index": chunk_index,
                            "heading": "No heading detected",
                            "source_file": filename,
                            "pages": [real_label]  # Exact page for table
                        })
                        chunk_index += 1
                    if page_text:  # Skip empty pages
                        if headings:
                            for text, _, _ in headings:
                                section_chunks, section_metadata, chunk_index = chunk_section(
                                    page_text, text, word_page_map, [real_label], filename, max_words, overlap, chunk_index
                                )
                                chunks.extend(section_chunks)
                                metadata.extend(section_metadata)
                        else:
                            section_chunks, section_metadata, chunk_index = chunk_section(
                                page_text, "No heading detected", word_page_map, [real_label], filename, max_words, overlap, chunk_index
                            )
                            chunks.extend(section_chunks)
                            metadata.extend(section_metadata)

        assert len(chunks) == len(metadata), f"Mismatch: {len(chunks)} chunks vs {len(metadata)} metadata"
        return chunks, metadata
    except Exception as e:
        logger.error(f"Failed to process PDF {pdf_path}: {e}")
        raise
--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/backend/chunker.py ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/approve/page.tsx ---

"use client"

import { useState } from "react"
import AnimationApproval from "@/components/quiz/animation-approval"
import { PageHeader } from "@/components/layout/page-header"
import { SparklesCore } from "@/components/sparkles"
import { FloatingPaper } from "@/components/floating-paper"
import { Shield, Lock } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"

export default function AdminApprovePage() {
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [password, setPassword] = useState("")
  const [error, setError] = useState("")

  const handleLogin = () => {
    if (password === "admin123") {
      setIsAuthenticated(true);
      setError("");
    } else {
      setError("Invalid password");
    }
  }

  if (!isAuthenticated) {
    return (
      <main className="min-h-screen bg-black/[0.96] antialiased bg-grid-white/[0.02] relative overflow-hidden">
        <div className="h-full w-full absolute inset-0 z-0">
          <SparklesCore
            id="tsparticlesfullpage"
            background="transparent"
            minSize={0.6}
            maxSize={1.4}
            particleDensity={100}
            className="w-full h-full"
            particleColor="#FFFFFF"
          />
        </div>

        <div className="absolute inset-0 overflow-hidden z-0">
          <FloatingPaper count={6} />
        </div>

        <div className="relative z-10 flex items-center justify-center min-h-screen p-4">
          <Card className="w-full max-w-md bg-white/5 border-white/10 backdrop-blur-sm">
            <CardHeader className="text-center">
              <div className="mx-auto w-12 h-12 bg-purple-600 rounded-full flex items-center justify-center mb-4">
                <Lock className="w-6 h-6 text-white" />
              </div>
              <CardTitle className="text-white">Admin Access</CardTitle>
              <CardDescription className="text-gray-400">Enter password to access animation approval</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <Input
                type="password"
                placeholder="Enter admin password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="bg-white/5 border-white/10 text-white placeholder:text-gray-400"
                onKeyPress={(e) => e.key === "Enter" && handleLogin()}
              />
              {error && <p className="text-red-400 text-sm">{error}</p>}
              <Button onClick={handleLogin} className="w-full bg-purple-600 hover:bg-purple-700">
                Login
              </Button>
            </CardContent>
          </Card>
        </div>
      </main>
    )
  }

  return (
    <main className="min-h-screen bg-black/[0.96] antialiased bg-grid-white/[0.02] relative overflow-hidden">
      <div className="h-full w-full absolute inset-0 z-0">
        <SparklesCore
          id="tsparticlesfullpage"
          background="transparent"
          minSize={0.6}
          maxSize={1.4}
          particleDensity={100}
          className="w-full h-full"
          particleColor="#FFFFFF"
        />
      </div>

      <div className="absolute inset-0 overflow-hidden z-0">
        <FloatingPaper count={6} />
      </div>

      <div className="relative z-10">
        <PageHeader title="Animation Approval" description="Manage quiz feedback animations" icon={<Shield />} />
        <AnimationApproval />
      </div>
    </main>
  )
}
--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/approve/page.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/quiz-generation/page.tsx ---

'use client';

import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import axios from 'axios';
import { toast } from 'sonner';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { PageHeader } from '@/components/layout/page-header';
import { SparklesCore } from '@/components/sparkles';
import { FloatingPaper } from '@/components/floating-paper';
import { Brain, FileText, Loader2, CheckCircle, XCircle } from 'lucide-react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';

interface Course {
  id: number;
  name: string;
}

interface Year {
  id: number;
  name: string;
}

interface Semester {
  id: number;
  name: string;
}

interface Unit {
  id: number;
  name: string;
}

interface Document {
  id: number;
  filename: string;
  filepath: string;
  course_path: string;
}

interface QuizGenerationJob {
  id: string;
  documentId: number;
  filename: string;
  coursePath: string;
  status: 'pending' | 'generating' | 'completed' | 'failed';
  progress: number;
  questionsGenerated: number;
}

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL ?? 'http://localhost:8000';

export default function QuizGenerationPage() {
  const [courses, setCourses] = useState<Course[]>([]);
  const [years, setYears] = useState<Year[]>([]);
  const [semesters, setSemesters] = useState<Semester[]>([]);
  const [units, setUnits] = useState<Unit[]>([]);
  const [documents, setDocuments] = useState<Document[]>([]);
  const [selectedCourseId, setSelectedCourseId] = useState<number | null>(null);
  const [selectedYearId, setSelectedYearId] = useState<number | null>(null);
  const [selectedSemesterId, setSelectedSemesterId] = useState<number | null>(null);
  const [selectedUnitId, setSelectedUnitId] = useState<number | null>(null);
  const [generationJobs, setGenerationJobs] = useState<QuizGenerationJob[]>([]);

  // Fetch courses on mount
  useEffect(() => {
    axios
      .get(`${API_BASE_URL}/courses`)
      .then((res) => setCourses(res.data))
      .catch((err) => toast.error('Failed to load courses'));
  }, []);

  // Fetch years when course is selected
  useEffect(() => {
    if (selectedCourseId) {
      axios
        .get(`${API_BASE_URL}/courses/${selectedCourseId}/years`)
        .then((res) => setYears(res.data))
        .catch((err) => toast.error('Failed to load years'));
      setYears([]);
      setSemesters([]);
      setUnits([]);
      setDocuments([]);
      setSelectedYearId(null);
      setSelectedSemesterId(null);
      setSelectedUnitId(null);
    }
  }, [selectedCourseId]);

  // Fetch semesters when year is selected
  useEffect(() => {
    if (selectedYearId) {
      axios
        .get(`${API_BASE_URL}/years/${selectedYearId}/semesters`)
        .then((res) => setSemesters(res.data))
        .catch((err) => toast.error('Failed to load semesters'));
      setSemesters([]);
      setUnits([]);
      setDocuments([]);
      setSelectedSemesterId(null);
      setSelectedUnitId(null);
    }
  }, [selectedYearId]);

  // Fetch units when semester is selected
  useEffect(() => {
    if (selectedSemesterId) {
      axios
        .get(`${API_BASE_URL}/semesters/${selectedSemesterId}/units`)
        .then((res) => setUnits(res.data))
        .catch((err) => toast.error('Failed to load units'));
      setUnits([]);
      setDocuments([]);
      setSelectedUnitId(null);
    }
  }, [selectedSemesterId]);

  // Fetch documents when unit is selected
  useEffect(() => {
    if (selectedUnitId) {
      axios
        .get(`${API_BASE_URL}/units/${selectedUnitId}/documents`)
        .then((res) => setDocuments(res.data))
        .catch((err) => toast.error('Failed to load documents'));
      setDocuments([]);
    }
  }, [selectedUnitId]);

  const handleGenerateQuiz = (documentId: number) => {
    const document = documents.find((d) => d.id === documentId);
    if (!document) return;

    const newJob: QuizGenerationJob = {
      id: `job_${Date.now()}`,
      documentId,
      filename: document.filename,
      coursePath: document.course_path,
      status: 'generating',
      progress: 0,
      questionsGenerated: 0,
    };

    setGenerationJobs((prev) => [...prev, newJob]);

    const evtSource = new EventSource(`${API_BASE_URL}/documents/${documentId}/generate-quiz`);

    evtSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data === '[DONE]') {
        setGenerationJobs((prev) =>
          prev.map((job) =>
            job.id === newJob.id ? { ...job, status: 'completed', progress: 100 } : job,
          ),
        );
        evtSource.close();
        toast.success('Quiz generation completed');
        return;
      }

      if (data.error) {
        setGenerationJobs((prev) =>
          prev.map((job) => (job.id === newJob.id ? { ...job, status: 'failed' } : job)),
        );
        evtSource.close();
        toast.error(data.error);
        return;
      }

      setGenerationJobs((prev) =>
        prev.map((job) =>
          job.id === newJob.id
            ? { ...job, progress: data.progress, questionsGenerated: data.questionsGenerated }
            : job,
        ),
      );
    };

    evtSource.onerror = () => {
      setGenerationJobs((prev) =>
        prev.map((job) => (job.id === newJob.id ? { ...job, status: 'failed' } : job)),
      );
      evtSource.close();
      toast.error('Error generating quiz');
    };

    // Cleanup on unmount
    return () => evtSource.close();
  };

  return (
    <div className="min-h-screen bg-black/[0.96] antialiased bg-grid-white/[0.02] relative overflow-hidden">
      {/* Ambient background */}
      <div className="h-full w-full absolute inset-0 z-0">
        <SparklesCore
          id="tsparticlesfullpage"
          background="transparent"
          minSize={0.6}
          maxSize={1.4}
          particleDensity={100}
          className="w-full h-full"
          particleColor="#FFFFFF"
        />
      </div>

      <div className="absolute inset-0 overflow-hidden z-0">
        <FloatingPaper count={6} />
      </div>

      <div className="relative z-10">
        <div className="container mx-auto p-6">
          <PageHeader
            title="Quiz Generation"
            description="Generate quizzes from processed documents"
            icon={<Brain className="h-6 w-6" />}
          />

          {/* Course Selection */}
          <Card className="mb-6 bg-white/5 border-white/10 backdrop-blur-sm">
            <CardHeader>
              <CardTitle className="text-white flex items-center">
                <FileText className="w-5 h-5 mr-2 text-purple-500" />
                Select Course Unit
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                  <label className="text-gray-400 text-sm mb-2 block">Course</label>
                  <Select
                    value={selectedCourseId?.toString() || ''}
                    onValueChange={(value) => setSelectedCourseId(Number(value))}
                  >
                    <SelectTrigger className="bg-white/5 border-white/10 text-white">
                      <SelectValue placeholder="Select course" />
                    </SelectTrigger>
                    <SelectContent className="bg-gray-900 border-white/20">
                      {courses.map((course) => (
                        <SelectItem key={course.id} value={course.id.toString()}>
                          {course.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                {years.length > 0 && (
                  <div>
                    <label className="text-gray-400 text-sm mb-2 block">Year</label>
                    <Select
                      value={selectedYearId?.toString() || ''}
                      onValueChange={(value) => setSelectedYearId(Number(value))}
                    >
                      <SelectTrigger className="bg-white/5 border-white/10 text-white">
                        <SelectValue placeholder="Select year" />
                      </SelectTrigger>
                      <SelectContent className="bg-gray-900 border-white/20">
                        {years.map((year) => (
                          <SelectItem key={year.id} value={year.id.toString()}>
                            {year.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}

                {semesters.length > 0 && (
                  <div>
                    <label className="text-gray-400 text-sm mb-2 block">Semester</label>
                    <Select
                      value={selectedSemesterId?.toString() || ''}
                      onValueChange={(value) => setSelectedSemesterId(Number(value))}
                    >
                      <SelectTrigger className="bg-white/5 border-white/10 text-white">
                        <SelectValue placeholder="Select semester" />
                      </SelectTrigger>
                      <SelectContent className="bg-gray-900 border-white/20">
                        {semesters.map((semester) => (
                          <SelectItem key={semester.id} value={semester.id.toString()}>
                            {semester.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}

                {units.length > 0 && (
                  <div>
                    <label className="text-gray-400 text-sm mb-2 block">Unit</label>
                    <Select
                      value={selectedUnitId?.toString() || ''}
                      onValueChange={(value) => setSelectedUnitId(Number(value))}
                    >
                      <SelectTrigger className="bg-white/5 border-white/10 text-white">
                        <SelectValue placeholder="Select unit" />
                      </SelectTrigger>
                      <SelectContent className="bg-gray-900 border-white/20">
                        {units.map((unit) => (
                          <SelectItem key={unit.id} value={unit.id.toString()}>
                            {unit.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Available Documents */}
          {selectedUnitId && (
            <Card className="mb-6 bg-white/5 border-white/10 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white">Available Documents</CardTitle>
                <p className="text-gray-400 text-sm">
                  Documents for {courses.find((c) => c.id === selectedCourseId)?.name} /{' '}
                  {years.find((y) => y.id === selectedYearId)?.name} /{' '}
                  {semesters.find((s) => s.id === selectedSemesterId)?.name} /{' '}
                  {units.find((u) => u.id === selectedUnitId)?.name}
                </p>
              </CardHeader>
              <CardContent>
                {documents.length === 0 ? (
                  <div className="text-center py-8">
                    <FileText className="mx-auto h-12 w-12 text-gray-400" />
                    <h3 className="mt-4 text-lg font-medium text-white">No documents found</h3>
                    <p className="mt-2 text-sm text-gray-400">Upload and process documents for this unit first</p>
                  </div>
                ) : (
                  <Table>
                    <TableHeader>
                      <TableRow className="border-white/10">
                        <TableHead className="text-gray-300">Filename</TableHead>
                        <TableHead className="text-gray-300">Course Path</TableHead>
                        <TableHead className="text-gray-300 text-right">Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {documents.map((doc) => (
                        <TableRow key={doc.id} className="border-white/10">
                          <TableCell className="text-white font-medium">{doc.filename}</TableCell>
                          <TableCell className="text-gray-400">{doc.course_path}</TableCell>
                          <TableCell className="text-right">
                            <Button
                              onClick={() => handleGenerateQuiz(doc.id)}
                              disabled={generationJobs.some((job) => job.documentId === doc.id && job.status === 'generating')}
                              size="sm"
                              className="bg-purple-600 hover:bg-purple-700 text-white"
                            >
                              {generationJobs.some((job) => job.documentId === doc.id && job.status === 'generating') ? (
                                <Loader2 className="w-4 h-4 animate-spin mr-2" />
                              ) : (
                                <Brain className="w-4 h-4 mr-2" />
                              )}
                              Generate Quiz
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                )}
              </CardContent>
            </Card>
          )}

          {/* Generation Jobs */}
          {generationJobs.length > 0 && (
            <Card className="bg-white/5 border-white/10 backdrop-blur-sm">
              <CardHeader>
                <CardTitle className="text-white">Quiz Generation Progress</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {generationJobs.map((job) => (
                  <motion.div
                    key={job.id}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="p-4 bg-white/5 rounded-lg border border-white/10"
                  >
                    <div className="flex items-center justify-between mb-2">
                      <div className="flex items-center space-x-3">
                        <div className="flex items-center space-x-2">
                          {job.status === 'generating' && <Loader2 className="w-4 h-4 animate-spin text-purple-500" />}
                          {job.status === 'completed' && <CheckCircle className="w-4 h-4 text-green-500" />}
                          {job.status === 'failed' && <XCircle className="w-4 h-4 text-red-500" />}
                          <span className="text-white font-medium">{job.filename}</span>
                        </div>
                        <Badge
                          className={
                            job.status === 'completed'
                              ? 'bg-green-600 text-white'
                              : job.status === 'failed'
                              ? 'bg-red-600 text-white'
                              : 'bg-purple-600 text-white'
                          }
                        >
                          {job.status}
                        </Badge>
                      </div>
                      {job.status === 'completed' && (
                        <span className="text-green-400 text-sm">{job.questionsGenerated} questions generated</span>
                      )}
                    </div>

                    <p className="text-gray-400 text-sm mb-3">{job.coursePath}</p>

                    {job.status === 'generating' && (
                      <div className="space-y-2">
                        <div className="flex items-center justify-between">
                          <span className="text-sm text-gray-400">Generating questions...</span>
                          <span className="text-sm font-medium text-white">{job.progress}%</span>
                        </div>
                        <Progress value={job.progress} className="h-2" />
                      </div>
                    )}
                  </motion.div>
                ))}
              </CardContent>
            </Card>
          )}
        </div>
      </div>
    </div>
  );
}
--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/quiz-generation/page.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/topics/[topicid]/page.tsx ---

'use client';

import { useParams } from 'next/navigation';
import { useState, useEffect } from 'react';
import axios from 'axios';
import { toast, Toaster } from 'sonner'; // Updated import
import QuizFeed from '@/components/quiz/quiz-feed';
import BottomNavigation from '@/components/layout/bottom-navigation';
import { SparklesCore } from '@/components/sparkles';
import { FloatingPaper } from '@/components/floating-paper';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { BookOpen, ArrowLeft, Play } from 'lucide-react';
import Link from 'next/link';

interface Course {
  id: number;
  name: string;
}

interface Year {
  id: number;
  name: string;
}

interface Semester {
  id: number;
  name: string;
}

interface Unit {
  id: number;
  name: string;
}

interface Quiz {
  id: number;
  unit_id: number;
  question: string;
  options: string[];
  correct_answer: string;
  explanation: string | null;
  chunk_id: number | null;
}

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8000';

export default function TopicDetailPage() {
  const params = useParams();
  const topicId = params.topicId as string;
  const courseId = Number(topicId);

  const [course, setCourse] = useState<Course | null>(null);
  const [years, setYears] = useState<Year[]>([]);
  const [semesters, setSemesters] = useState<Semester[]>([]);
  const [units, setUnits] = useState<Unit[]>([]);
  const [availableQuizzes, setAvailableQuizzes] = useState<Quiz[]>([]);
  const [selectedYearId, setSelectedYearId] = useState<number | null>(null);
  const [selectedSemesterId, setSelectedSemesterId] = useState<number | null>(null);
  const [selectedUnitId, setSelectedUnitId] = useState<number | null>(null);
  const [showQuizFeed, setShowQuizFeed] = useState(false);

  // Fetch course details
  useEffect(() => {
    axios
      .get(`${API_BASE_URL}/courses/${courseId}`)
      .then((res) => setCourse(res.data))
      .catch((err) => toast.error('Failed to load course details')); // Sonner toast
  }, [courseId]);

  // Fetch years
  useEffect(() => {
    if (courseId) {
      axios
        .get(`${API_BASE_URL}/courses/${courseId}/years`)
        .then((res) => setYears(res.data))
        .catch((err) => toast.error('Failed to load years')); // Sonner toast
    }
  }, [courseId]);

  // Fetch semesters when year is selected
  useEffect(() => {
    if (selectedYearId) {
      axios
        .get(`${API_BASE_URL}/years/${selectedYearId}/semesters`)
        .then((res) => setSemesters(res.data))
        .catch((err) => toast.error('Failed to load semesters')); // Sonner toast
      setSemesters([]);
      setUnits([]);
      setAvailableQuizzes([]);
      setSelectedSemesterId(null);
      setSelectedUnitId(null);
      setShowQuizFeed(false);
    }
  }, [selectedYearId]);

  // Fetch units when semester is selected
  useEffect(() => {
    if (selectedSemesterId) {
      axios
        .get(`${API_BASE_URL}/semesters/${selectedSemesterId}/units`)
        .then((res) => setUnits(res.data))
        .catch((err) => toast.error('Failed to load units')); // Sonner toast
      setUnits([]);
      setAvailableQuizzes([]);
      setSelectedUnitId(null);
      setShowQuizFeed(false);
    }
  }, [selectedSemesterId]);

  // therapeutical
  // Fetch quizzes when unit is selected
  useEffect(() => {
    if (selectedUnitId) {
      axios
        .get(`${API_BASE_URL}/units/${selectedUnitId}/quizzes`)
        .then((res) => {
          const formattedQuizzes = res.data.map((quiz: any) => ({
            ...quiz,
            options: JSON.parse(quiz.options), // Convert JSON string to array
          }));
          setAvailableQuizzes(formattedQuizzes);
        })
        .catch((err) => toast.error('Failed to load quizzes')); // Sonner toast
      setAvailableQuizzes([]);
      setShowQuizFeed(false);
    }
  }, [selectedUnitId]);

  const handleStartQuiz = () => {
    if (availableQuizzes.length > 0) {
      setShowQuizFeed(true);
    } else {
      toast.error('No quizzes available for this unit'); // Sonner toast
    }
  };

  if (showQuizFeed && availableQuizzes.length > 0) {
    return (
      <main className="min-h-screen bg-black/[0.96] antialiased bg-grid-white/[0.02] relative overflow-hidden">
        {/* Ambient background */}
        <div className="h-full w-full absolute inset-0 z-0">
          <SparklesCore
            id="tsparticlesfullpage"
            background="transparent"
            minSize={0.6}
            maxSize={1.4}
            particleDensity={100}
            className="w-full h-full"
            particleColor="#FFFFFF"
          />
        </div>

        <div className="absolute inset-0 overflow-hidden z-0">
          <FloatingPaper count={6} />
        </div>

        <div className="relative z-10 pb-20">
          <QuizFeed quizzes={availableQuizzes} onExit={() => setShowQuizFeed(false)} />
          <Toaster /> {/* Add Sonner Toaster */}
        </div>

        <BottomNavigation />
      </main>
    );
  }

  if (!course) {
    return (
      <div className="min-h-screen bg-black/[0.96] flex items-center justify-center">
        <div className="text-white text-center">
          <h1 className="text-2xl font-bold mb-4">Course not found</h1>
          <Link href="/topics">
            <Button className="bg-purple-600 hover:bg-purple-700">Back to Courses</Button>
          </Link>
        </div>
      </div>
    );
  }

  return (
    <main className="min-h-screen bg-black/[0.96] antialiased bg-grid-white/[0.02] relative overflow-hidden">
      {/* Ambient background */}
      <div className="h-full w-full absolute inset-0 z-0">
        <SparklesCore
          id="tsparticlesfullpage"
          background="transparent"
          minSize={0.6}
          maxSize={1.4}
          particleDensity={100}
          className="w-full h-full"
          particleColor="#FFFFFF"
        />
      </div>

      <div className="absolute inset-0 overflow-hidden z-0">
        <FloatingPaper count={6} />
      </div>

      <div className="relative z-10 pb-20">
        <Toaster /> {/* Add Sonner Toaster */}
        <div className="container mx-auto p-6">
          {/* Header with back button */}
          <div className="flex items-center mb-6">
            <Link href="/topics">
              <Button variant="ghost" size="sm" className="text-white hover:bg-white/10 mr-4">
                <ArrowLeft className="w-4 h-4 mr-2" />
                Back
              </Button>
            </Link>
            <div className="flex items-center space-x-3">
              <div className="w-12 h-12 rounded-full flex items-center justify-center text-2xl bg-purple-500">
                <BookOpen className="text-white" />
              </div>
              <div>
                <h1 className="text-3xl font-bold text-white">{course.name}</h1>
                <p className="text-gray-400">Select your year, semester, and unit to start quizzing</p>
              </div>
            </div>
          </div>

          {/* Course Selection */}
          <Card className="mb-6 bg-white/5 border-white/10 backdrop-blur-sm">
            <CardHeader>
              <CardTitle className="text-white flex items-center">
                <BookOpen className="w-5 h-5 mr-2 text-purple-500" />
                Select Course Unit
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <label className="text-gray-400 text-sm mb-2 block">Year</label>
                  <Select
                    value={selectedYearId?.toString() || ''}
                    onValueChange={(value) => setSelectedYearId(Number(value))}
                  >
                    <SelectTrigger className="bg-white/5 border-white/10 text-white">
                      <SelectValue placeholder="Select year" />
                    </SelectTrigger>
                    <SelectContent className="bg-gray-900 border-white/20">
                      {years.map((year) => (
                        <SelectItem key={year.id} value={year.id.toString()}>
                          {year.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                {semesters.length > 0 && (
                  <div>
                    <label className="text-gray-400 text-sm mb-2 block">Semester</label>
                    <Select
                      value={selectedSemesterId?.toString() || ''}
                      onValueChange={(value) => setSelectedSemesterId(Number(value))}
                    >
                      <SelectTrigger className="bg-white/5 border-white/10 text-white">
                        <SelectValue placeholder="Select semester" />
                      </SelectTrigger>
                      <SelectContent className="bg-gray-900 border-white/20">
                        {semesters.map((semester) => (
                          <SelectItem key={semester.id} value={semester.id.toString()}>
                            {semester.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}

                {units.length > 0 && (
                  <div>
                    <label className="text-gray-400 text-sm mb-2 block">Unit</label>
                    <Select
                      value={selectedUnitId?.toString() || ''}
                      onValueChange={(value) => setSelectedUnitId(Number(value))}
                    >
                      <SelectTrigger className="bg-white/5 border-white/10 text-white">
                        <SelectValue placeholder="Select unit" />
                      </SelectTrigger>
                      <SelectContent className="bg-gray-900 border-white/20">
                        {units.map((unit) => (
                          <SelectItem key={unit.id} value={unit.id.toString()}>
                            {unit.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}
              </div>

                           {/* Quiz Preview */}
              {selectedUnitId && (
                <Card className="bg-white/5 border-white/10 backdrop-blur-sm">
                  <CardContent className="p-6">
                    <div className="text-center">
                      <h3 className="text-xl font-bold text-white mb-2">
                        {availableQuizzes.length} Quiz{availableQuizzes.length !== 1 ? 'es' : ''} Available
                      </h3>
                      <p className="text-gray-400 mb-4">
                        {course.name} / {years.find((y) => y.id === selectedYearId)?.name} /{' '}
                        {semesters.find((s) => s.id === selectedSemesterId)?.name} /{' '}
                        {units.find((u) => u.id === selectedUnitId)?.name}
                      </p>

                      {availableQuizzes.length > 0 ? (
                        <Button
                          onClick={handleStartQuiz}
                          size="lg"
                          className="bg-purple-600 hover:bg-purple-700 text-white"
                        >
                          <Play className="w-5 h-5 mr-2" />
                          Start Quiz
                        </Button>
                      ) : (
                        <div className="text-center py-4">
                          <p className="text-gray-400">No quizzes available for this unit yet.</p>
                          <p className="text-sm text-gray-500 mt-2">
                            Quizzes will be generated once documents are processed for this unit.
                          </p>
                        </div>
                      )}
                    </div> {/* <-- This closing tag was missing */}
                  </CardContent>
                </Card>
              )}
              </CardContent>
            </Card>
          </div>
        </div>

        <BottomNavigation />
      </main>
    );
  
}
--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/topics/[topicid]/page.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/topics/page.tsx ---

import TopicsGrid from "@/components/topics/topics-grid"
import { motion } from "framer-motion"
import BottomNavigation from "@/components/layout/bottom-navigation"
import PageHeader from "@/components/layout/page-header"
import { SparklesCore } from "@/components/sparkles"
import { FloatingPaper } from "@/components/floating-paper"
import { BookOpen } from "lucide-react"

export default function TopicsPage() {
  return (
    <main className="min-h-screen bg-black/[0.96] antialiased bg-grid-white/[0.02] relative overflow-hidden">
      {/* Ambient background */}
      <div className="h-full w-full absolute inset-0 z-0">
        <SparklesCore
          id="tsparticlesfullpage"
          background="transparent"
          minSize={0.6}
          maxSize={1.4}
          particleDensity={100}
          className="w-full h-full"
          particleColor="#FFFFFF"
        />
      </div>

      {/* Floating papers background */}
      <div className="absolute inset-0 overflow-hidden z-0">
        <FloatingPaper count={6} />
      </div>

      <div className="relative z-10 pb-20">
        <PageHeader title="Topics" description="Choose your learning adventure" icon={BookOpen} />
        <TopicsGrid />
      </div>

      <BottomNavigation />
    </main>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/app/topics/page.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/layout/bottom-navigation.tsx ---

"use client"

import { useRouter, usePathname } from "next/navigation"
import { motion } from "framer-motion"
import { Home, BookOpen, User } from "lucide-react"

const navItems = [
  { icon: Home, label: "Home", path: "/" },
  { icon: BookOpen, label: "Topics", path: "/topics" },
  { icon: User, label: "Profile", path: "/profile" },
]

export default function BottomNavigation() {
  const router = useRouter()
  const pathname = usePathname()

  return (
    <motion.nav
      className="fixed bottom-0 left-0 right-0 bg-black/80 backdrop-blur-sm border-t border-white/10 z-50"
      initial={{ y: 100 }}
      animate={{ y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="flex items-center justify-around py-2">
        {navItems.map((item) => {
          const Icon = item.icon
          const isActive = pathname === item.path

          return (
            <motion.button
              key={item.path}
              onClick={() => router.push(item.path)}
              className="flex flex-col items-center py-2 px-4 relative"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Icon className={`w-6 h-6 ${isActive ? "text-purple-500" : "text-gray-400"}`} />
              <span className={`text-xs mt-1 ${isActive ? "text-purple-500" : "text-gray-400"}`}>{item.label}</span>

              {isActive && (
                <motion.div
                  className="absolute bottom-0 left-1/2 w-8 h-0.5 bg-purple-500 rounded-full"
                  layoutId="activeTab"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  style={{ x: "-50%" }}
                />
              )}
            </motion.button>
          )
        })}
      </div>
    </motion.nav>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/layout/bottom-navigation.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/layout/page-header.tsx ---

import type React from "react"

interface PageHeaderProps {
  title: string
  description?: string
  icon?: React.ReactNode
}

export function PageHeader({ title, description, icon }: PageHeaderProps) {
  return (
    <div className="mb-8">
      <div className="flex items-center gap-2">
        {icon && <div className="text-purple-500">{icon}</div>}
        <h1 className="text-3xl font-bold tracking-tight text-white">{title}</h1>
      </div>
      {description && <p className="mt-2 text-gray-400">{description}</p>}
    </div>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/layout/page-header.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/quiz-feed.tsx ---

"use client"

import { useState, useRef, useEffect } from "react"
import { motion } from "framer-motion"
import { Button } from "@/components/ui/button"
import { ArrowLeft } from "lucide-react"
import QuizCard from "./quiz-card"
import type { Quiz } from "@/lib/types/quiz"

interface QuizFeedProps {
  quizzes: Quiz[]
  onExit: () => void
}

export default function QuizFeed({ quizzes, onExit }: QuizFeedProps) {
  const [currentQuiz, setCurrentQuiz] = useState(0)
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const container = containerRef.current
    if (!container) return

    const handleScroll = () => {
      const scrollTop = container.scrollTop
      const cardHeight = container.clientHeight
      const newIndex = Math.round(scrollTop / cardHeight)
      setCurrentQuiz(Math.max(0, Math.min(newIndex, quizzes.length - 1)))
    }

    container.addEventListener("scroll", handleScroll)
    return () => container.removeEventListener("scroll", handleScroll)
  }, [quizzes.length])

  return (
    <div className="relative h-screen">
      {/* Exit Button */}
      <motion.div
        className="absolute top-4 left-4 z-30"
        initial={{ opacity: 0, x: -20 }}
        animate={{ opacity: 1, x: 0 }}
      >
        <Button
          onClick={onExit}
          variant="ghost"
          size="sm"
          className="bg-black/50 text-white hover:bg-black/70 backdrop-blur-sm"
        >
          <ArrowLeft className="w-4 h-4 mr-2" />
          Exit Quiz
        </Button>
      </motion.div>

      {/* Quiz Progress */}
      <motion.div
        className="absolute top-4 right-4 z-30"
        initial={{ opacity: 0, x: 20 }}
        animate={{ opacity: 1, x: 0 }}
      >
        <div className="bg-black/50 text-white px-3 py-1 rounded-full text-sm backdrop-blur-sm">
          {currentQuiz + 1} / {quizzes.length}
        </div>
      </motion.div>

      <div
        ref={containerRef}
        className="h-screen overflow-y-scroll snap-y snap-mandatory"
        style={{
          scrollbarWidth: "none",
          msOverflowStyle: "none",
          WebkitScrollbar: { display: "none" },
        }}
      >
        <style jsx>{`
          div::-webkit-scrollbar {
            display: none;
          }
        `}</style>
        {quizzes.map((quiz, index) => (
          <motion.div
            key={quiz.id}
            className="h-screen snap-start"
            initial={{ opacity: 0, y: 50 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: index * 0.1 }}
          >
            <QuizCard quiz={quiz} isActive={index === currentQuiz} />
          </motion.div>
        ))}
      </div>
    </div>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/quiz-feed.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/animation-approval.tsx ---

"use client"

import type React from "react"
import { useState, useEffect } from "react"
import { motion } from "framer-motion"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Badge } from "@/components/ui/badge"
import { Upload, Play, Pause, Check, X, FileVideo, ImageIcon } from "lucide-react"
import axios from "axios"
import { toast } from "sonner"

interface UploadedFile {
  file: File
  preview: string
  progress: number
  status: "uploading" | "uploaded" | "approved" | "rejected"
  unitId?: string
}

interface Unit {
  id: number
  name: string
}
interface Semester {
  id: number
  name: string
  units: Unit[]
}
interface Year {
  id: number
  name: string
  semesters: Semester[]
}
interface Course {
  id: number
  name: string
  years: Year[]
}

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL ?? "http://localhost:8000"

export default function AnimationApproval() {
  const [courses, setCourses] = useState<Course[]>([])
  const [selectedCourseId, setSelectedCourseId] = useState("")
  const [selectedYearId, setSelectedYearId] = useState("")
  const [selectedSemesterId, setSelectedSemesterId] = useState("")
  const [selectedUnitId, setSelectedUnitId] = useState("")
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([])
  const [isPlaying, setIsPlaying] = useState<{ [key: number]: boolean }>({})

  // Get the cascaded objects for selection (matching your document upload system)
  const selectedCourse = courses.find((c) => c.id.toString() === selectedCourseId)
  const years = selectedCourse?.years ?? []
  const selectedYear = years.find((y) => y.id.toString() === selectedYearId)
  const semesters = selectedYear?.semesters ?? []
  const selectedSemester = semesters.find((s) => s.id.toString() === selectedSemesterId)
  const units = selectedSemester?.units ?? []

  useEffect(() => {
    // Fetch courses using your existing API
    axios
      .get(`${API_BASE_URL}/courses/`)
      .then((res) => setCourses(res.data))
      .catch((err) => toast.error("Failed to load courses"))
  }, [])

  // Reset deeper selects when a parent is changed (matching your document upload logic)
  useEffect(() => {
    setSelectedYearId("")
    setSelectedSemesterId("")
    setSelectedUnitId("")
  }, [selectedCourseId])
  useEffect(() => {
    setSelectedSemesterId("")
    setSelectedUnitId("")
  }, [selectedYearId])
  useEffect(() => {
    setSelectedUnitId("")
  }, [selectedSemesterId])

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || [])

    files.forEach((file) => {
      if (file.size > 5 * 1024 * 1024) {
        toast.error("File size must be less than 5MB")
        return
      }

      const preview = URL.createObjectURL(file)
      const newFile: UploadedFile = {
        file,
        preview,
        progress: 0,
        status: "uploading",
        unitId: selectedUnitId,
      }

      setUploadedFiles((prev) => [...prev, newFile])

      // Simulate upload progress (similar to your document upload)
      const interval = setInterval(() => {
        setUploadedFiles((prev) =>
          prev.map((f) => (f.file === file ? { ...f, progress: Math.min(f.progress + 10, 100) } : f)),
        )
      }, 200)

      setTimeout(() => {
        clearInterval(interval)
        setUploadedFiles((prev) => prev.map((f) => (f.file === file ? { ...f, progress: 100, status: "uploaded" } : f)))
      }, 2000)
    })
  }

  const handleApproval = async (index: number, approved: boolean) => {
    const file = uploadedFiles[index]
    if (!file.unitId) {
      toast.error("Unit information missing")
      return
    }

    try {
      // Here you would typically send the approval to your backend
      // For now, we'll just update the local state
      setUploadedFiles((prev) =>
        prev.map((f, i) => (i === index ? { ...f, status: approved ? "approved" : "rejected" } : f)),
      )

      if (approved) {
        toast.success("Animation approved and linked to unit")
        // In a real implementation, you'd move the file to the appropriate location
        // and link it to the selected unit for quiz feedback screens
      } else {
        toast.success("Animation rejected")
      }
    } catch (error) {
      toast.error("Failed to process approval")
    }
  }

  const togglePlayback = (index: number) => {
    setIsPlaying((prev) => ({ ...prev, [index]: !prev[index] }))
  }

  return (
    <div className="p-6 space-y-6">
      {/* Course Selection - Matching your document upload system */}
      <Card className="bg-white/5 border-white/10 backdrop-blur-sm">
        <CardHeader>
          <CardTitle className="text-white flex items-center">
            <Upload className="w-5 h-5 mr-2 text-purple-500" />
            Course Selection
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div>
              <label className="text-gray-400 text-sm mb-2 block">Course</label>
              <Select value={selectedCourseId} onValueChange={setSelectedCourseId}>
                <SelectTrigger className="bg-white/5 border-white/10 text-white">
                  <SelectValue placeholder="Select course" />
                </SelectTrigger>
                <SelectContent className="bg-gray-900 border-white/20">
                  {courses.map((course) => (
                    <SelectItem key={course.id} value={course.id.toString()}>
                      {course.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {years.length > 0 && (
              <div>
                <label className="text-gray-400 text-sm mb-2 block">Year</label>
                <Select value={selectedYearId} onValueChange={setSelectedYearId}>
                  <SelectTrigger className="bg-white/5 border-white/10 text-white">
                    <SelectValue placeholder="Select year" />
                  </SelectTrigger>
                  <SelectContent className="bg-gray-900 border-white/20">
                    {years.map((year) => (
                      <SelectItem key={year.id} value={year.id.toString()}>
                        {year.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            {semesters.length > 0 && (
              <div>
                <label className="text-gray-400 text-sm mb-2 block">Semester</label>
                <Select value={selectedSemesterId} onValueChange={setSelectedSemesterId}>
                  <SelectTrigger className="bg-white/5 border-white/10 text-white">
                    <SelectValue placeholder="Select semester" />
                  </SelectTrigger>
                  <SelectContent className="bg-gray-900 border-white/20">
                    {semesters.map((semester) => (
                      <SelectItem key={semester.id} value={semester.id.toString()}>
                        {semester.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            {units.length > 0 && (
              <div>
                <label className="text-gray-400 text-sm mb-2 block">Unit</label>
                <Select value={selectedUnitId} onValueChange={setSelectedUnitId}>
                  <SelectTrigger className="bg-white/5 border-white/10 text-white">
                    <SelectValue placeholder="Select unit" />
                  </SelectTrigger>
                  <SelectContent className="bg-gray-900 border-white/20">
                    {units.map((unit) => (
                      <SelectItem key={unit.id} value={unit.id.toString()}>
                        {unit.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}
          </div>
        </CardContent>
      </Card>

      {/* File Upload - Matching your document upload styling */}
      <Card className="bg-white/5 border-white/10 backdrop-blur-sm">
        <CardHeader>
          <CardTitle className="text-white flex items-center">
            <FileVideo className="w-5 h-5 mr-2 text-purple-500" />
            Animation Upload
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="border-2 border-dashed border-white/20 rounded-lg p-8 text-center">
            <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
              <input
                type="file"
                accept=".mp4,.gif"
                multiple
                onChange={handleFileUpload}
                className="hidden"
                id="file-upload"
                disabled={!selectedUnitId}
              />
              <label
                htmlFor="file-upload"
                className={`cursor-pointer ${!selectedUnitId ? "opacity-50 cursor-not-allowed" : ""}`}
              >
                <Upload className="w-12 h-12 text-purple-500 mx-auto mb-4" />
                <p className="text-white mb-2">Click to upload animations</p>
                <p className="text-gray-400 text-sm">MP4 or GIF files, max 5MB each</p>
              </label>
            </motion.div>
          </div>

          {!selectedUnitId && (
            <p className="text-yellow-400 text-sm mt-2 text-center">
              Please select a course, year, semester, and unit first
            </p>
          )}
        </CardContent>
      </Card>

      {/* Uploaded Files - Similar to your document processing display */}
      {uploadedFiles.length > 0 && (
        <Card className="bg-white/5 border-white/10 backdrop-blur-sm">
          <CardHeader>
            <CardTitle className="text-white">Uploaded Animations</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {uploadedFiles.map((uploadedFile, index) => (
              <motion.div
                key={index}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.1 }}
                className="p-4 bg-white/5 rounded-lg border border-white/10"
              >
                <div className="flex items-start space-x-4">
                  {/* Preview */}
                  <div className="relative w-32 h-24 bg-black rounded-lg overflow-hidden">
                    {uploadedFile.file.type.startsWith("video/") ? (
                      <video
                        src={uploadedFile.preview}
                        className="w-full h-full object-cover"
                        muted
                        loop
                        ref={(video) => {
                          if (video) {
                            if (isPlaying[index]) {
                              video.play()
                            } else {
                              video.pause()
                            }
                          }
                        }}
                      />
                    ) : (
                      <img
                        src={uploadedFile.preview || "/placeholder.svg"}
                        alt="Preview"
                        className="w-full h-full object-cover"
                      />
                    )}

                    {uploadedFile.file.type.startsWith("video/") && (
                      <button
                        onClick={() => togglePlayback(index)}
                        className="absolute inset-0 flex items-center justify-center bg-black/50 hover:bg-black/70 transition-colors"
                      >
                        {isPlaying[index] ? (
                          <Pause className="w-6 h-6 text-white" />
                        ) : (
                          <Play className="w-6 h-6 text-white" />
                        )}
                      </button>
                    )}
                  </div>

                  {/* File Info */}
                  <div className="flex-1">
                    <div className="flex items-center space-x-2 mb-2">
                      {uploadedFile.file.type.startsWith("video/") ? (
                        <FileVideo className="w-4 h-4 text-purple-500" />
                      ) : (
                        <ImageIcon className="w-4 h-4 text-purple-500" />
                      )}
                      <span className="text-white font-medium">{uploadedFile.file.name}</span>
                      <Badge variant="outline" className="text-gray-400 border-gray-600">
                        {(uploadedFile.file.size / 1024).toFixed(1)} KB
                      </Badge>
                    </div>

                    {/* Progress Bar - Matching your document upload progress */}
                    {uploadedFile.status === "uploading" && (
                      <div className="mb-3">
                        <Progress value={uploadedFile.progress} className="h-2" />
                        <p className="text-gray-400 text-sm mt-1">Uploading... {uploadedFile.progress}%</p>
                      </div>
                    )}

                    {/* Status Badge */}
                    <div className="mb-3">
                      <Badge
                        className={
                          uploadedFile.status === "approved"
                            ? "bg-green-600 text-white"
                            : uploadedFile.status === "rejected"
                              ? "bg-red-600 text-white"
                              : uploadedFile.status === "uploaded"
                                ? "bg-yellow-600 text-white"
                                : "bg-blue-600 text-white"
                        }
                      >
                        {uploadedFile.status === "approved" && "Approved"}
                        {uploadedFile.status === "rejected" && "Rejected"}
                        {uploadedFile.status === "uploaded" && "Pending Review"}
                        {uploadedFile.status === "uploading" && "Uploading"}
                      </Badge>
                    </div>

                    {/* Action Buttons - Matching your document action styling */}
                    {uploadedFile.status === "uploaded" && (
                      <motion.div
                        className="flex space-x-2"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ delay: 0.5 }}
                      >
                        <Button
                          onClick={() => handleApproval(index, true)}
                          size="sm"
                          className="bg-green-600 hover:bg-green-700 text-white"
                        >
                          <Check className="w-4 h-4 mr-1" />
                          Approve
                        </Button>
                        <Button onClick={() => handleApproval(index, false)} size="sm" variant="destructive">
                          <X className="w-4 h-4 mr-1" />
                          Reject
                        </Button>
                      </motion.div>
                    )}
                  </div>
                </div>
              </motion.div>
            ))}
          </CardContent>
        </Card>
      )}
    </div>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/animation-approval.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/feedback-screen.tsx ---

"use client"

import { motion } from "framer-motion"
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { CheckCircle, XCircle, ArrowRight } from "lucide-react"
import type { Quiz } from "@/lib/types/quiz"

interface FeedbackScreenProps {
  quiz: Quiz
  selectedAnswer: string | null
  onNext: () => void
  points: number
  streak: number
}

export default function FeedbackScreen({ quiz, selectedAnswer, onNext, points, streak }: FeedbackScreenProps) {
  const isCorrect = selectedAnswer === quiz.correctAnswer

  return (
    <div className="h-full relative flex items-center justify-center p-4">
      {/* Background */}
      <div
        className="absolute inset-0 bg-cover bg-center"
        style={{
          backgroundImage: `linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.6)), url(${quiz.backgroundImage})`,
        }}
      />

      {/* Stats Update */}
      <motion.div
        className="absolute top-4 left-4 right-4 flex justify-between items-center z-20"
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex space-x-4">
          <motion.div
            className="bg-purple-600 px-3 py-1 rounded-full text-white text-sm font-medium"
            initial={{ scale: 1 }}
            animate={{ scale: [1, 1.2, 1] }}
            transition={{ duration: 0.5 }}
          >
            {points} Points{" "}
            {isCorrect && (
              <motion.span initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} className="text-green-300">
                +10
              </motion.span>
            )}
          </motion.div>
          <motion.div
            className="bg-orange-500 px-3 py-1 rounded-full text-white text-sm font-medium"
            initial={{ scale: 1 }}
            animate={{ scale: [1, 1.2, 1] }}
            transition={{ duration: 0.5, delay: 0.1 }}
          >
            {streak} Day Streak
          </motion.div>
        </div>
      </motion.div>

      {/* Feedback Content */}
      <Card className="w-full max-w-md bg-white/5 border-white/10 backdrop-blur-sm relative z-10">
        <div className="p-6 text-center">
          {/* Result Icon */}
          <motion.div
            initial={{ scale: 0, rotate: -180 }}
            animate={{ scale: 1, rotate: 0 }}
            transition={{ type: "spring", duration: 0.6 }}
            className="mb-4"
          >
            {isCorrect ? (
              <CheckCircle className="w-16 h-16 text-green-500 mx-auto" />
            ) : (
              <XCircle className="w-16 h-16 text-red-500 mx-auto" />
            )}
          </motion.div>

          {/* Result Text */}
          <motion.h2
            className={`text-2xl font-bold mb-4 ${isCorrect ? "text-green-400" : "text-red-400"}`}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            {isCorrect ? "Correct!" : "Incorrect!"}
          </motion.h2>

          {/* Explanation */}
          <motion.p
            className="text-white mb-6"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5 }}
          >
            {quiz.explanation}
          </motion.p>

          {/* Correct Answer */}
          {!isCorrect && (
            <motion.div
              className="mb-6 p-3 bg-green-500/20 rounded-lg border border-green-500/30"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.7 }}
            >
              <p className="text-green-400 text-sm">
                Correct answer: <span className="font-medium">{quiz.correctAnswer}</span>
              </p>
            </motion.div>
          )}

          {/* Next Button */}
          <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ delay: 0.9 }}>
            <Button onClick={onNext} className="w-full bg-purple-600 hover:bg-purple-700 text-white" size="lg">
              Next Quiz
              <ArrowRight className="ml-2 w-4 h-4" />
            </Button>
          </motion.div>
        </div>
      </Card>
    </div>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/feedback-screen.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/share-button.tsx ---

"use client"

import { useState } from "react"
import { motion } from "framer-motion"
import { Button } from "@/components/ui/button"
import { Share2, Twitter, MessageCircle, Copy } from "lucide-react"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import type { Quiz } from "@/lib/types/quiz"

interface ShareButtonProps {
  quiz: Quiz
  score?: number
  total?: number
}

export default function ShareButton({ quiz, score = 1, total = 1 }: ShareButtonProps) {
  const [isOpen, setIsOpen] = useState(false)

  const shareText = `I just scored ${score}/${total} on "${quiz.question}" in QuizEdu! 🎓✨ #QuizEdu #Learning`
  const shareUrl = typeof window !== "undefined" ? window.location.href : ""

  const handleTwitterShare = () => {
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`
    window.open(twitterUrl, "_blank")
  }

  const handleWhatsAppShare = () => {
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(`${shareText} ${shareUrl}`)}`
    window.open(whatsappUrl, "_blank")
  }

  const handleCopyLink = async () => {
    try {
      await navigator.clipboard.writeText(`${shareText} ${shareUrl}`)
      // You could show a toast notification here
    } catch (err) {
      console.error("Failed to copy:", err)
    }
  }

  const handleNativeShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: "QuizEdu",
          text: shareText,
          url: shareUrl,
        })
      } catch (err) {
        console.error("Error sharing:", err)
      }
    }
  }

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <motion.div whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.95 }}>
          <Button size="sm" variant="outline" className="bg-white/10 border-white/20 text-white hover:bg-white/20">
            <Share2 className="w-4 h-4" />
          </Button>
        </motion.div>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-gray-900 border-gray-700">
        <DropdownMenuItem onClick={handleTwitterShare} className="text-white hover:bg-gray-800">
          <Twitter className="w-4 h-4 mr-2" />
          Share on Twitter
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleWhatsAppShare} className="text-white hover:bg-gray-800">
          <MessageCircle className="w-4 h-4 mr-2" />
          Share on WhatsApp
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleCopyLink} className="text-white hover:bg-gray-800">
          <Copy className="w-4 h-4 mr-2" />
          Copy Link
        </DropdownMenuItem>
        {navigator.share && (
          <DropdownMenuItem onClick={handleNativeShare} className="text-white hover:bg-gray-800">
            <Share2 className="w-4 h-4 mr-2" />
            More Options
          </DropdownMenuItem>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/share-button.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/quiz-card.tsx ---

"use client"

import { useState, useEffect } from "react"
import { motion } from "framer-motion"
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { Timer } from "lucide-react"
import FeedbackScreen from "./feedback-screen"
import ShareButton from "./share-button"
import type { Quiz } from "@/lib/types/quiz"

interface QuizCardProps {
  quiz: Quiz
  isActive: boolean
}

export default function QuizCard({ quiz, isActive }: QuizCardProps) {
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null)
  const [showFeedback, setShowFeedback] = useState(false)
  const [timeLeft, setTimeLeft] = useState(10)
  const [points, setPoints] = useState(1250)
  const [streak, setStreak] = useState(5)

  useEffect(() => {
    if (!isActive || showFeedback) return

    const timer = setInterval(() => {
      setTimeLeft((prev) => {
        if (prev <= 1) {
          setShowFeedback(true)
          return 0
        }
        return prev - 1
      })
    }, 1000)

    return () => clearInterval(timer)
  }, [isActive, showFeedback])

  const handleAnswerSelect = (answer: string) => {
    setSelectedAnswer(answer)
    setShowFeedback(true)

    if (answer === quiz.correctAnswer) {
      setPoints((prev) => prev + 10)
      setStreak((prev) => prev + 1)
    }
  }

  const handleNextQuiz = () => {
    setSelectedAnswer(null)
    setShowFeedback(false)
    setTimeLeft(10)
  }

  if (showFeedback) {
    return (
      <FeedbackScreen
        quiz={quiz}
        selectedAnswer={selectedAnswer}
        onNext={handleNextQuiz}
        points={points}
        streak={streak}
      />
    )
  }

  return (
    <div className="h-full relative flex items-center justify-center p-4">
      {/* Background Image */}
      <div
        className="absolute inset-0 bg-cover bg-center"
        style={{
          backgroundImage: `linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4)), url(${quiz.backgroundImage})`,
        }}
      />

      {/* Stats Bar */}
      <motion.div
        className="absolute top-4 left-4 right-4 flex justify-between items-center z-20"
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        <div className="flex space-x-4">
          <motion.div
            className="bg-purple-600 px-3 py-1 rounded-full text-white text-sm font-medium"
            whileHover={{ scale: 1.05 }}
          >
            {points} Points
          </motion.div>
          <motion.div
            className="bg-orange-500 px-3 py-1 rounded-full text-white text-sm font-medium"
            whileHover={{ scale: 1.05 }}
          >
            {streak} Day Streak
          </motion.div>
        </div>
        <ShareButton quiz={quiz} />
      </motion.div>

      {/* Timer Bar */}
      <motion.div className="absolute top-16 left-4 right-4 z-20" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
        <div className="flex items-center space-x-2 mb-2">
          <Timer className="w-4 h-4 text-white" />
          <span className="text-white text-sm">{timeLeft}s</span>
        </div>
        <div className="w-full bg-white/20 rounded-full h-2">
          <motion.div
            className="bg-purple-600 h-2 rounded-full"
            initial={{ width: "100%" }}
            animate={{ width: `${(timeLeft / 10) * 100}%` }}
            transition={{ duration: 1, ease: "linear" }}
          />
        </div>
      </motion.div>

      {/* Quiz Content */}
      <Card className="w-full max-w-md bg-white/5 border-white/10 backdrop-blur-sm relative z-10">
        <div className="p-6">
          <motion.h2
            className="text-2xl font-bold text-white mb-6 text-center"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
          >
            {quiz.question}
          </motion.h2>

          <div className="space-y-3">
            {quiz.options.map((option, index) => (
              <motion.div
                key={option}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: 0.3 + index * 0.1 }}
              >
                <Button
                  onClick={() => handleAnswerSelect(option)}
                  className="w-full bg-white/10 hover:bg-white/20 text-white border border-white/20 text-left justify-start h-12"
                  variant="outline"
                >
                  <span className="mr-3 w-6 h-6 bg-purple-600 rounded-full flex items-center justify-center text-sm font-medium">
                    {String.fromCharCode(65 + index)}
                  </span>
                  {option}
                </Button>
              </motion.div>
            ))}
          </div>

          <motion.div
            className="mt-4 text-center"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.7 }}
          >
            <span className="text-purple-400 text-sm">{quiz.topic}</span>
          </motion.div>
        </div>
      </Card>
    </div>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/quiz/quiz-card.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/topics/topics-grid.tsx ---

"use client"

import { motion } from "framer-motion"
import { Card } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { useRouter } from "next/navigation"
import { topicsData } from "@/lib/data/topics-data"
import { getQuizzesByTopic } from "@/lib/data/quiz-data"

export default function TopicsGrid() {
  const router = useRouter()

  return (
    <div className="p-6">
      <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
        {topicsData.map((topic, index) => {
          const quizCount = getQuizzesByTopic(topic.name).length

          return (
            <motion.div
              key={topic.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: index * 0.1 }}
              whileHover={{ scale: 1.05, y: -5 }}
              whileTap={{ scale: 0.95 }}
            >
              <Card
                className="bg-white/5 border-white/10 backdrop-blur-sm cursor-pointer overflow-hidden group"
                onClick={() => router.push(`/topics/${topic.id}`)}
              >
                <div className="p-6 text-center">
                  {/* Topic Icon */}
                  <motion.div
                    className={`w-16 h-16 mx-auto mb-4 rounded-full flex items-center justify-center text-2xl ${topic.color}`}
                    whileHover={{ rotate: 360 }}
                    transition={{ duration: 0.6 }}
                  >
                    {topic.icon}
                  </motion.div>

                  {/* Topic Name */}
                  <h3 className="text-white font-semibold mb-2 group-hover:text-purple-400 transition-colors">
                    {topic.name}
                  </h3>

                  {/* Quiz Count */}
                  <Badge variant="secondary" className="bg-purple-600/20 text-purple-400 border-purple-600/30">
                    {quizCount} quiz{quizCount !== 1 ? "es" : ""} available
                  </Badge>

                  {/* Progress Bar */}
                  <div className="mt-3 w-full bg-white/10 rounded-full h-2">
                    <motion.div
                      className="bg-purple-600 h-2 rounded-full"
                      initial={{ width: 0 }}
                      animate={{ width: `${topic.progress}%` }}
                      transition={{ duration: 1, delay: index * 0.1 + 0.5 }}
                    />
                  </div>
                  <p className="text-gray-400 text-xs mt-1">{topic.progress}% complete</p>
                </div>
              </Card>
            </motion.div>
          )
        })}
      </div>
    </div>
  )
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/components/topics/topics-grid.tsx ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/types/chat.ts ---

// /frontend/types/chat.ts

export interface Citation {
  heading?: string
  pages?: number[] | null
  file?: string
}

export interface ChatMessage {
  id: string
  type: "user" | "assistant"
  content: string
  timestamp: Date
  saved?: boolean
  isStreaming?: boolean
  citations?: Citation[]     // <-- Updated to match back-end payload
}

export interface ChatSession {
  id: string
  unitId: number
  unitName: string
  coursePath: string
  messages: ChatMessage[]
  timestamp: Date
}

export interface Course {
  id: number
  name: string
}

export interface Year {
  id: number
  name: string
}

export interface Semester {
  id: number
  name: string
}

export interface Unit {
  id: number
  name: string
}

--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/types/chat.ts ---


--- START OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/types/quiz.ts ---

export interface Quiz {
  id: number;
  unit_id: number;
  question: string;
  options: string[];
  correct_answer: string;
  explanation: string | null;
  chunk_id: number | null;
  course_path: string;
}
--- END OF /home/rick110/RickDrive/AI Projects/FASTAPI+NEXTJS+RAG/frontend/types/quiz.ts ---

